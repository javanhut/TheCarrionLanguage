<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî§ String Grimoire - Master of Text Magic - Carrion Language Wiki</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üê¶‚Äç‚¨õ</text></svg>">
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #cccccc;
            --text-secondary: #999999;
            --accent-primary: #00cc99;
            --accent-secondary: #9900cc;
            --accent-warning: #ffcc00;
            --border-color: #333355;
            --code-bg: #0f0f1a;
            --link-color: #66ccff;
            --link-hover: #99ddff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 20px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            border: 2px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(45deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 1.2em;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .ascii-art {
            font-family: monospace;
            font-size: 0.7em;
            line-height: 1.2;
            color: var(--accent-primary);
            margin: 20px 0;
            white-space: pre;
        }

        .navigation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .nav-section {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 15px;
            padding: 25px;
            transition: all 0.3s ease;
        }

        .nav-section:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 5px 20px rgba(0, 204, 153, 0.1);
            transform: translateY(-2px);
        }

        .nav-section h2 {
            color: var(--accent-primary);
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .nav-section ul {
            list-style: none;
        }

        .nav-section li {
            margin: 8px 0;
        }

        .nav-section a {
            color: var(--link-color);
            text-decoration: none;
            font-size: 1.05em;
            transition: color 0.3s ease;
        }

        .nav-section a:hover {
            color: var(--link-hover);
            text-shadow: 0 0 10px rgba(102, 204, 255, 0.3);
        }

        .content {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 40px;
        }

        .content h1, .content h2, .content h3 {
            color: var(--accent-primary);
            margin: 30px 0 15px 0;
        }

        .content h1 {
            font-size: 2.5em;
            border-bottom: 3px solid var(--accent-primary);
            padding-bottom: 10px;
        }

        .content p {
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .content pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Fira Code', 'Courier New', monospace;
        }

        .content code {
            background: var(--code-bg);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Courier New', monospace;
            color: var(--accent-primary);
        }

        .content blockquote {
            border-left: 4px solid var(--accent-primary);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--bg-tertiary);
            border-radius: 0 10px 10px 0;
        }

        .table-of-contents {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .table-of-contents h2 {
            color: var(--accent-secondary);
            margin-bottom: 15px;
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: var(--text-secondary);
            border-top: 2px solid var(--border-color);
            margin-top: 40px;
        }

        .badge {
            display: inline-block;
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin: 5px;
        }

        .emoji {
            font-size: 1.2em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .container {
                padding: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .navigation {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content"><h1 id="%F0%9F%94%A4-string-grimoire---master-of-text-magic" tabindex="-1"><a class="header-anchor" href="#%F0%9F%94%A4-string-grimoire---master-of-text-magic">üî§ String Grimoire - Master of Text Magic</a></h1>
<p>Welcome to the <strong>String Grimoire</strong>, the mystical tome of text manipulation in the Munin standard library! Transform simple text into powerful magical incantations with sophisticated string operations, text analysis, and character manipulation spells.</p>
<hr>
<h2 id="%F0%9F%AA%84-what-is-the-string-grimoire%3F" tabindex="-1"><a class="header-anchor" href="#%F0%9F%AA%84-what-is-the-string-grimoire%3F">ü™Ñ What is the String Grimoire?</a></h2>
<p>The <strong>String Grimoire</strong> enhances Carrion‚Äôs basic strings with powerful text magic:</p>
<ul>
<li>üîç <strong>Text Analysis</strong> - Search, find, and analyze text content</li>
<li>üé≠ <strong>Transformation</strong> - Change case, reverse, and modify text</li>
<li>üìê <strong>Character Access</strong> - Precise character-level manipulation</li>
<li>‚ú® <strong>Validation</strong> - Check text properties and content</li>
<li>üîß <strong>Text Building</strong> - Construct complex strings efficiently</li>
</ul>
<hr>
<h2 id="%F0%9F%8E%AD-creating-string-magic" tabindex="-1"><a class="header-anchor" href="#%F0%9F%8E%AD-creating-string-magic">üé≠ Creating String Magic</a></h2>
<h3 id="basic-string-enhancement" tabindex="-1"><a class="header-anchor" href="#basic-string-enhancement">Basic String Enhancement</a></h3>
<pre><code class="language-python">// Create strings the normal way
basic_text = &quot;Hello, magical world!&quot;
spell_name = &quot;Fireball&quot;
incantation = &quot;Abracadabra&quot;

// Enhance them with String grimoire magic
magical_text = String(&quot;Hello, magical world!&quot;)
enhanced_spell = String(spell_name)

// Strings also get automatic enhancement!
auto_enhanced = &quot;Automatic magic!&quot;
print(auto_enhanced.upper())  // Works automatically! Returns &quot;AUTOMATIC MAGIC!&quot;
</code></pre>
<h3 id="string-grimoire-constructor" tabindex="-1"><a class="header-anchor" href="#string-grimoire-constructor">String Grimoire Constructor</a></h3>
<pre><code class="language-python">// Various ways to create magical strings
from_text = String(&quot;Ancient runes&quot;)
from_variable = String(some_variable)
from_number = String(42)           // &quot;42&quot;
from_boolean = String(True)        // &quot;True&quot;
empty_spell = String(&quot;&quot;)
</code></pre>
<hr>
<h2 id="%F0%9F%93%8A-text-analysis-spells" tabindex="-1"><a class="header-anchor" href="#%F0%9F%93%8A-text-analysis-spells">üìä Text Analysis Spells</a></h2>
<h3 id=".length()---measure-your-text-magic" tabindex="-1"><a class="header-anchor" href="#.length()---measure-your-text-magic"><code>.length()</code> - Measure Your Text Magic</a></h3>
<pre><code class="language-python">incantation = String(&quot;Expecto Patronum&quot;)
spell_power = incantation.length()
print(f&quot;Spell has {spell_power} characters&quot;)  // 15 characters

// Also works with auto-enhanced strings
auto_text = &quot;Magical!&quot;
print(f&quot;Length: {auto_text.length()}&quot;)  // 8

// Perfect for validation
password = String(input(&quot;Enter magical password: &quot;))
if password.length() &gt;= 8:
    print(&quot;Password meets minimum length requirement!&quot;)
else:
    print(f&quot;Password too short! Need {8 - password.length()} more characters.&quot;)
</code></pre>
<h3 id=".contains(substring)---detect-text-presence" tabindex="-1"><a class="header-anchor" href="#.contains(substring)---detect-text-presence"><code>.contains(substring)</code> - Detect Text Presence</a></h3>
<pre><code class="language-python">magical_tome = String(&quot;The ancient grimoire contains powerful fire spells&quot;)

// Search for magical elements
has_fire = magical_tome.contains(&quot;fire&quot;)
has_water = magical_tome.contains(&quot;water&quot;)
has_ancient = magical_tome.contains(&quot;ancient&quot;)

print(f&quot;Contains fire magic: {has_fire}&quot;)      // True
print(f&quot;Contains water magic: {has_water}&quot;)    // False
print(f&quot;Contains ancient knowledge: {has_ancient}&quot;)  // True

// Case-sensitive searching
spell_book = String(&quot;FireBall&quot;)
print(spell_book.contains(&quot;fire&quot;))     // False (lowercase 'f')
print(spell_book.contains(&quot;Fire&quot;))     // True
print(spell_book.contains(&quot;FIRE&quot;))     // False (all caps)
</code></pre>
<h3 id=".find(substring)---locate-magical-text" tabindex="-1"><a class="header-anchor" href="#.find(substring)---locate-magical-text"><code>.find(substring)</code> - Locate Magical Text</a></h3>
<pre><code class="language-python">magical_recipe = String(&quot;Mix dragon scale with phoenix feather and unicorn hair&quot;)

// Find ingredient positions
dragon_pos = magical_recipe.find(&quot;dragon&quot;)
phoenix_pos = magical_recipe.find(&quot;phoenix&quot;)
unicorn_pos = magical_recipe.find(&quot;unicorn&quot;)
missing_pos = magical_recipe.find(&quot;troll blood&quot;)

print(f&quot;Dragon mentioned at position: {dragon_pos}&quot;)    // 4
print(f&quot;Phoenix mentioned at position: {phoenix_pos}&quot;)  // 22
print(f&quot;Unicorn mentioned at position: {unicorn_pos}&quot;)  // 43
print(f&quot;Troll blood position: {missing_pos}&quot;)          // -1 (not found)

// Use for conditional magic
if magical_recipe.find(&quot;dangerous&quot;) != -1:
    print(&quot;‚ö†Ô∏è Warning: Recipe contains dangerous ingredients!&quot;)
else:
    print(&quot;‚úÖ Recipe appears safe to brew&quot;)
</code></pre>
<hr>
<h2 id="%F0%9F%94%8D-character-access-spells" tabindex="-1"><a class="header-anchor" href="#%F0%9F%94%8D-character-access-spells">üîç Character Access Spells</a></h2>
<h3 id=".char_at(index)---extract-individual-characters" tabindex="-1"><a class="header-anchor" href="#.char_at(index)---extract-individual-characters"><code>.char_at(index)</code> - Extract Individual Characters</a></h3>
<pre><code class="language-python">magic_word = String(&quot;ABRACADABRA&quot;)

// Positive indexing (0-based)
first_char = magic_word.char_at(0)      // &quot;A&quot;
third_char = magic_word.char_at(2)      // &quot;R&quot;
print(f&quot;First character: {first_char}&quot;)
print(f&quot;Third character: {third_char}&quot;)

// Negative indexing (from the end)
last_char = magic_word.char_at(-1)      // &quot;A&quot;
second_last = magic_word.char_at(-2)    // &quot;R&quot;
print(f&quot;Last character: {last_char}&quot;)
print(f&quot;Second to last: {second_last}&quot;)

// Safe access (returns empty string for invalid indices)
beyond = magic_word.char_at(20)         // &quot;&quot;
print(f&quot;Beyond range: '{beyond}'&quot;)

// Build character maps
spell analyze_spell_characters(spell_text):
    spell_string = String(spell_text)
    char_frequency = {}
    
    for i in range(spell_string.length()):
        char = spell_string.char_at(i)
        if char in char_frequency:
            char_frequency[char] += 1
        else:
            char_frequency[char] = 1
    
    return char_frequency

char_analysis = analyze_spell_characters(&quot;ABRACADABRA&quot;)
print(f&quot;Character frequency: {char_analysis}&quot;)
// Output: {&quot;A&quot;: 5, &quot;B&quot;: 2, &quot;R&quot;: 2, &quot;C&quot;: 1, &quot;D&quot;: 1}
</code></pre>
<hr>
<h2 id="%F0%9F%8E%AD-text-transformation-spells" tabindex="-1"><a class="header-anchor" href="#%F0%9F%8E%AD-text-transformation-spells">üé≠ Text Transformation Spells</a></h2>
<h3 id=".upper()-%26-.lower()---change-magical-case" tabindex="-1"><a class="header-anchor" href="#.upper()-%26-.lower()---change-magical-case"><code>.upper()</code> &amp; <code>.lower()</code> - Change Magical Case</a></h3>
<pre><code class="language-python">quiet_spell = String(&quot;whispered healing charm&quot;)
loud_spell = String(&quot;THUNDEROUS LIGHTNING BOLT&quot;)

// Transform case
amplified = quiet_spell.upper()
hushed = loud_spell.lower()

print(f&quot;Amplified: {amplified}&quot;)  // &quot;WHISPERED HEALING CHARM&quot;
print(f&quot;Hushed: {hushed}&quot;)        // &quot;thunderous lightning bolt&quot;

// Perfect for user input normalization
user_command = String(input(&quot;Enter spell name: &quot;))
normalized_command = user_command.lower()

if normalized_command == &quot;fireball&quot;:
    print(&quot;üî• Casting Fireball!&quot;)
elif normalized_command == &quot;heal&quot;:
    print(&quot;üíö Casting Healing Magic!&quot;)
else:
    print(&quot;‚ùì Unknown spell command&quot;)

// Create title case manually
spell create_title_case(text):
    title_string = String(text.lower())
    words = title_string.to_string().split(&quot; &quot;)
    title_words = []
    
    for word in words:
        if len(word) &gt; 0:
            word_string = String(word)
            first_char = word_string.char_at(0).upper()
            rest_chars = word_string.to_string()[1:]
            title_words.append(first_char + rest_chars)
    
    return &quot; &quot;.join(title_words)

title = create_title_case(&quot;the ancient book of fire spells&quot;)
print(f&quot;Title case: {title}&quot;)  // &quot;The Ancient Book Of Fire Spells&quot;
</code></pre>
<h3 id=".reverse()---mirror-your-text-magic" tabindex="-1"><a class="header-anchor" href="#.reverse()---mirror-your-text-magic"><code>.reverse()</code> - Mirror Your Text Magic</a></h3>
<pre><code class="language-python">magical_code = String(&quot;ABRACADABRA&quot;)
reversed_code = magical_code.reverse()

print(f&quot;Original: {magical_code.to_string()}&quot;)   // &quot;ABRACADABRA&quot;
print(f&quot;Reversed: {reversed_code}&quot;)              // &quot;ARBADACARBA&quot;

// Check for palindromic spells
spell is_palindromic_spell(spell_text):
    spell_string = String(spell_text.lower())
    reversed_string = spell_string.reverse()
    return spell_string.to_string() == reversed_string

print(is_palindromic_spell(&quot;ABRACADABRA&quot;))  // False
print(is_palindromic_spell(&quot;racecar&quot;))      // True
print(is_palindromic_spell(&quot;A man a plan a canal Panama&quot;))  // False (spaces matter)

// Create mirror spells
spell create_mirror_incantation(base_spell):
    base_string = String(base_spell)
    mirror = base_string.reverse()
    return f&quot;{base_spell} {mirror}&quot;

mirror_spell = create_mirror_incantation(&quot;MAGIC&quot;)
print(f&quot;Mirror spell: {mirror_spell}&quot;)  // &quot;MAGIC CIGAM&quot;
</code></pre>
<hr>
<h2 id="%F0%9F%94%A7-string-building-%26-manipulation" tabindex="-1"><a class="header-anchor" href="#%F0%9F%94%A7-string-building-%26-manipulation">üîß String Building &amp; Manipulation</a></h2>
<h3 id=".to_string()---access-raw-text" tabindex="-1"><a class="header-anchor" href="#.to_string()---access-raw-text"><code>.to_string()</code> - Access Raw Text</a></h3>
<pre><code class="language-python">enhanced_text = String(&quot;Magical Enhancement&quot;)
raw_text = enhanced_text.to_string()

print(f&quot;Enhanced: {enhanced_text}&quot;)  // The String object
print(f&quot;Raw: {raw_text}&quot;)           // &quot;Magical Enhancement&quot;

// Use for string concatenation and manipulation
spell combine_spell_components(*components):
    combined = &quot;&quot;
    for component in components:
        component_string = String(component)
        combined += component_string.to_string() + &quot; + &quot;
    
    // Remove the last &quot; + &quot;
    if len(combined) &gt;= 3:
        combined = combined[:-3]
    
    return f&quot;Spell formula: {combined}&quot;

formula = combine_spell_components(&quot;Fire Essence&quot;, &quot;Wind Spirit&quot;, &quot;Earth Power&quot;)
print(formula)  // &quot;Spell formula: Fire Essence + Wind Spirit + Earth Power&quot;
</code></pre>
<hr>
<h2 id="%F0%9F%8E%AA-advanced-string-magic" tabindex="-1"><a class="header-anchor" href="#%F0%9F%8E%AA-advanced-string-magic">üé™ Advanced String Magic</a></h2>
<h3 id="text-pattern-analysis" tabindex="-1"><a class="header-anchor" href="#text-pattern-analysis">Text Pattern Analysis</a></h3>
<pre><code class="language-python">spell analyze_magical_text(text):
    text_string = String(text)
    
    analysis = {
        &quot;length&quot;: text_string.length(),
        &quot;uppercase_count&quot;: 0,
        &quot;lowercase_count&quot;: 0,
        &quot;digit_count&quot;: 0,
        &quot;space_count&quot;: 0,
        &quot;vowel_count&quot;: 0,
        &quot;consonant_count&quot;: 0
    }
    
    vowels = &quot;aeiouAEIOU&quot;
    
    for i in range(text_string.length()):
        char = text_string.char_at(i)
        
        if char.isupper():
            analysis[&quot;uppercase_count&quot;] += 1
        elif char.islower():
            analysis[&quot;lowercase_count&quot;] += 1
        elif char.isdigit():
            analysis[&quot;digit_count&quot;] += 1
        elif char == &quot; &quot;:
            analysis[&quot;space_count&quot;] += 1
        
        if char in vowels:
            analysis[&quot;vowel_count&quot;] += 1
        elif char.isalpha():
            analysis[&quot;consonant_count&quot;] += 1
    
    return analysis

spell_analysis = analyze_magical_text(&quot;The Quick Brown Fox Jumps Over 123 Lazy Dogs!&quot;)
print(&quot;Magical text analysis:&quot;)
for key, value in spell_analysis.items():
    print(f&quot;  {key}: {value}&quot;)
</code></pre>
<h3 id="magical-text-validation" tabindex="-1"><a class="header-anchor" href="#magical-text-validation">Magical Text Validation</a></h3>
<pre><code class="language-python">spell validate_spell_name(name):
    name_string = String(name)
    errors = []
    
    // Check length
    if name_string.length() &lt; 3:
        errors.append(&quot;Spell name too short (minimum 3 characters)&quot;)
    elif name_string.length() &gt; 50:
        errors.append(&quot;Spell name too long (maximum 50 characters)&quot;)
    
    // Check for forbidden characters
    forbidden = &quot;!@#$%^&amp;*()=+[]{}|\\:;\&quot;'&lt;&gt;?,.&quot;
    for i in range(name_string.length()):
        char = name_string.char_at(i)
        if forbidden.find(char) != -1:
            errors.append(f&quot;Forbidden character found: '{char}'&quot;)
            stop
    
    // Check that it starts with a letter
    if name_string.length() &gt; 0:
        first_char = name_string.char_at(0)
        if not (first_char.upper() &gt;= &quot;A&quot; and first_char.upper() &lt;= &quot;Z&quot;):
            errors.append(&quot;Spell name must start with a letter&quot;)
    
    // Check for required elements
    if not (name_string.contains(&quot;Fire&quot;) or name_string.contains(&quot;Ice&quot;) or 
            name_string.contains(&quot;Lightning&quot;) or name_string.contains(&quot;Heal&quot;)):
        errors.append(&quot;Spell name must contain a magical element&quot;)
    
    return {
        &quot;valid&quot;: len(errors) == 0,
        &quot;errors&quot;: errors,
        &quot;name&quot;: name_string.to_string()
    }

// Test spell name validation
test_names = [&quot;Fire&quot;, &quot;Lightning Bolt&quot;, &quot;Mega Fire Blast&quot;, &quot;Invalid@Spell&quot;, &quot;A&quot;]

for name in test_names:
    result = validate_spell_name(name)
    if result[&quot;valid&quot;]:
        print(f&quot;‚úÖ '{result['name']}' is a valid spell name&quot;)
    else:
        print(f&quot;‚ùå '{result['name']}' is invalid:&quot;)
        for error in result[&quot;errors&quot;]:
            print(f&quot;   - {error}&quot;)
</code></pre>
<h3 id="magical-text-search-%26-replace" tabindex="-1"><a class="header-anchor" href="#magical-text-search-%26-replace">Magical Text Search &amp; Replace</a></h3>
<pre><code class="language-python">spell magical_text_processor(text):
    text_string = String(text)
    
    spell find_all_occurrences(search_text):
        positions = []
        start_pos = 0
        
        while True:
            pos = text_string.find(search_text)
            if pos == -1:
                stop
            positions.append(pos)
            // Note: This is simplified - real implementation would need
            // to search from different starting positions
            stop
        
        return positions
    
    spell replace_magical_words():
        // Replace common magical terms with enhanced versions
        enhanced_text = text_string.to_string()
        
        replacements = {
            &quot;magic&quot;: &quot;MYSTICAL POWER&quot;,
            &quot;spell&quot;: &quot;ARCANE INCANTATION&quot;,
            &quot;wand&quot;: &quot;ENCHANTED STAFF&quot;,
            &quot;potion&quot;: &quot;MAGICAL ELIXIR&quot;
        }
        
        for old_word, new_word in replacements.items():
            enhanced_text = enhanced_text.replace(old_word, new_word)
        
        return String(enhanced_text)
    
    spell count_magical_words():
        magical_words = [&quot;magic&quot;, &quot;spell&quot;, &quot;enchant&quot;, &quot;mystical&quot;, &quot;arcane&quot;]
        count = 0
        
        for word in magical_words:
            if text_string.contains(word):
                count += 1
        
        return count
    
    return {
        &quot;find&quot;: find_all_occurrences,
        &quot;enhance&quot;: replace_magical_words,
        &quot;count_magic&quot;: count_magical_words,
        &quot;original&quot;: text_string
    }

// Use the magical text processor
processor = magical_text_processor(&quot;This magic spell uses a wand to create a potion&quot;)
enhanced = processor[&quot;enhance&quot;]()
magic_count = processor[&quot;count_magic&quot;]()

print(f&quot;Original: {processor['original'].to_string()}&quot;)
print(f&quot;Enhanced: {enhanced.to_string()}&quot;)
print(f&quot;Magical words found: {magic_count}&quot;)
</code></pre>
<hr>
<h2 id="%F0%9F%8E%AF-practical-string-magic-examples" tabindex="-1"><a class="header-anchor" href="#%F0%9F%8E%AF-practical-string-magic-examples">üéØ Practical String Magic Examples</a></h2>
<h3 id="magical-password-generator" tabindex="-1"><a class="header-anchor" href="#magical-password-generator">Magical Password Generator</a></h3>
<pre><code class="language-python">spell generate_magical_password(length = 12, include_symbols = True):
    if length &lt; 4:
        return &quot;Password too short for magical security!&quot;
    
    // Magical character sets
    lowercase = &quot;abcdefghijklmnopqrstuvwxyz&quot;
    uppercase = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
    numbers = &quot;0123456789&quot;
    magical_symbols = &quot;*@#$%&amp;!?&quot;
    
    all_chars = lowercase + uppercase + numbers
    if include_symbols:
        all_chars += magical_symbols
    
    password_chars = []
    
    // Ensure at least one of each type
    password_chars.append(lowercase[random_index(len(lowercase))])
    password_chars.append(uppercase[random_index(len(uppercase))])
    password_chars.append(numbers[random_index(len(numbers))])
    
    if include_symbols:
        password_chars.append(magical_symbols[random_index(len(magical_symbols))])
    
    // Fill remaining length with random characters
    for i in range(len(password_chars), length):
        password_chars.append(all_chars[random_index(len(all_chars))])
    
    // Shuffle the password (simplified)
    // In real implementation, you'd want a proper shuffle
    password = &quot;&quot;.join(password_chars)
    return String(password)

// Note: This is a simplified example
// Real implementation would need proper random number generation
</code></pre>
<h3 id="magical-text-adventure-parser" tabindex="-1"><a class="header-anchor" href="#magical-text-adventure-parser">Magical Text Adventure Parser</a></h3>
<pre><code class="language-python">spell create_text_adventure_parser():
    spell parse_command(user_input):
        input_string = String(user_input.lower().strip())
        
        // Define command patterns
        move_words = [&quot;go&quot;, &quot;move&quot;, &quot;walk&quot;, &quot;run&quot;, &quot;travel&quot;]
        take_words = [&quot;take&quot;, &quot;get&quot;, &quot;grab&quot;, &quot;pick&quot;, &quot;collect&quot;]
        use_words = [&quot;use&quot;, &quot;cast&quot;, &quot;activate&quot;, &quot;invoke&quot;]
        
        words = input_string.to_string().split(&quot; &quot;)
        if len(words) == 0:
            return {&quot;action&quot;: &quot;unknown&quot;, &quot;object&quot;: &quot;&quot;, &quot;direction&quot;: &quot;&quot;}
        
        action_word = words[0]
        object_word = words[1] if len(words) &gt; 1 else &quot;&quot;
        
        // Determine action type
        if action_word in move_words:
            return {
                &quot;action&quot;: &quot;move&quot;,
                &quot;direction&quot;: object_word,
                &quot;object&quot;: &quot;&quot;
            }
        elif action_word in take_words:
            return {
                &quot;action&quot;: &quot;take&quot;,
                &quot;object&quot;: object_word,
                &quot;direction&quot;: &quot;&quot;
            }
        elif action_word in use_words:
            return {
                &quot;action&quot;: &quot;use&quot;,
                &quot;object&quot;: object_word,
                &quot;direction&quot;: &quot;&quot;
            }
        else:
            return {
                &quot;action&quot;: &quot;unknown&quot;,
                &quot;object&quot;: object_word,
                &quot;direction&quot;: &quot;&quot;
            }
    
    spell format_response(action_data):
        action = action_data[&quot;action&quot;]
        
        if action == &quot;move&quot;:
            direction = action_data[&quot;direction&quot;]
            if direction in [&quot;north&quot;, &quot;south&quot;, &quot;east&quot;, &quot;west&quot;]:
                return f&quot;üö∂ Moving {direction}...&quot;
            else:
                return &quot;‚ùì Where do you want to go? (north/south/east/west)&quot;
        
        elif action == &quot;take&quot;:
            object_name = action_data[&quot;object&quot;]
            if object_name:
                return f&quot;üëã Attempting to take {object_name}...&quot;
            else:
                return &quot;‚ùì What do you want to take?&quot;
        
        elif action == &quot;use&quot;:
            object_name = action_data[&quot;object&quot;]
            if object_name:
                return f&quot;‚ú® Attempting to use {object_name}...&quot;
            else:
                return &quot;‚ùì What do you want to use?&quot;
        
        else:
            return &quot;‚ùì I don't understand that command. Try: go [direction], take [item], or use [item]&quot;
    
    return {
        &quot;parse&quot;: parse_command,
        &quot;respond&quot;: format_response
    }

// Use the text adventure parser
parser = create_text_adventure_parser()

test_commands = [
    &quot;go north&quot;,
    &quot;take sword&quot;,
    &quot;use magic wand&quot;,
    &quot;dance wildly&quot;,
    &quot;pick up treasure&quot;
]

for command in test_commands:
    parsed = parser[&quot;parse&quot;](command)
    response = parser[&quot;respond&quot;](parsed)
    print(f&quot;Command: '{command}' -&gt; {response}&quot;)
</code></pre>
<hr>
<h2 id="%F0%9F%8F%86-string-magic-challenges" tabindex="-1"><a class="header-anchor" href="#%F0%9F%8F%86-string-magic-challenges">üèÜ String Magic Challenges</a></h2>
<h3 id="%F0%9F%A5%89-beginner-challenges" tabindex="-1"><a class="header-anchor" href="#%F0%9F%A5%89-beginner-challenges">ü•â Beginner Challenges</a></h3>
<ol>
<li><strong>Spell Name Generator</strong>: Create random magical spell names using string manipulation</li>
<li><strong>Text Encoder</strong>: Create a simple magical cipher for encoding messages</li>
<li><strong>Word Counter</strong>: Count specific words in magical texts</li>
</ol>
<h3 id="%F0%9F%A5%88-intermediate-challenges" tabindex="-1"><a class="header-anchor" href="#%F0%9F%A5%88-intermediate-challenges">ü•à Intermediate Challenges</a></h3>
<ol>
<li><strong>Magical Anagram Detector</strong>: Find if two spell names are anagrams</li>
<li><strong>Text Formatter</strong>: Format magical texts with proper spacing and capitalization</li>
<li><strong>Spell Pattern Matcher</strong>: Match text patterns for spell recognition</li>
</ol>
<h3 id="%F0%9F%A5%87-advanced-challenges" tabindex="-1"><a class="header-anchor" href="#%F0%9F%A5%87-advanced-challenges">ü•á Advanced Challenges</a></h3>
<ol>
<li><strong>Magical Language Translator</strong>: Create a fantasy language translator</li>
<li><strong>Advanced Text Parser</strong>: Build a command parser for magical interfaces</li>
<li><strong>Spell Completion System</strong>: Create autocomplete for magical spell names</li>
</ol>
<hr>
<h2 id="%F0%9F%94%97-related-magic" tabindex="-1"><a class="header-anchor" href="#%F0%9F%94%97-related-magic">üîó Related Magic</a></h2>
<p>Explore other grimoires that work well with strings:</p>
<ul>
<li><strong><a href="Array-Grimoire.md">Array Grimoire</a></strong> - For working with arrays of strings</li>
<li><strong><a href="File-OS-Grimoires.md">File &amp; OS Grimoires</a></strong> - For reading/writing text files</li>
<li><strong><a href="../Reference/Builtin-Functions.md">Builtin Functions</a></strong> - Core functions for string operations</li>
<li><strong><a href="../Language-Fundamentals/Functions.md">Functions (Spells)</a></strong> - Create custom string processing spells</li>
</ul>
<hr>
<h2 id="%F0%9F%92%A1-string-mastery-tips" tabindex="-1"><a class="header-anchor" href="#%F0%9F%92%A1-string-mastery-tips">üí° String Mastery Tips</a></h2>
<ol>
<li><strong>üîç Use <code>.find()</code> for Positions</strong>: Better than manual searching for substrings</li>
<li><strong>üìê Leverage Negative Indexing</strong>: <code>.char_at(-1)</code> for last character access</li>
<li><strong>üé≠ Normalize for Comparisons</strong>: Use <code>.lower()</code> for case-insensitive operations</li>
<li><strong>üõ°Ô∏è Validate Input</strong>: Always check string properties before processing</li>
<li><strong>‚ö° Chain String Operations</strong>: Combine multiple transformations efficiently</li>
<li><strong>üìä Analyze Before Processing</strong>: Use length and content checks for safety</li>
</ol>
<hr>
<p><em>Master the String Grimoire, and you‚Äôll wield the power to manipulate text like ancient runic magic! Every character becomes a tool, every word a component in your magical arsenal. ü™Ñ‚ú®</em></p>
<blockquote>
<p>‚ÄúIn the realm of text, every character holds power, and every string tells a story waiting to be transformed.‚Äù - <em>Master String Enchanter</em></p>
</blockquote>
</div>
    </div>
    <div class="footer">
        <p>ü™Ñ Carrion Programming Language Wiki - Where Code Meets Magic ‚ú®</p>
        <p>Built with ‚ù§Ô∏è by the Carrion Community | <a href="https://github.com/javanhut/TheCarrionLanguage" style="color: var(--link-color);">GitHub Repository</a></p>
    </div>
</body>
</html>