grim String:
    init(value = ""):
        self.value = str(value)
    
    // Conversion methods
    spell to_int():
        return int(self.value)
    
    spell to_float():
        return float(self.value)
    
    spell to_boolean():
        return len(self.value) > 0
    
    spell to_array():
        return list(self.value)
    
    // String operations
    spell length():
        return len(self.value)
    
    spell concat(other):
        return String(self.value + str(other))
    
    spell repeat(times):
        if type(times) == "INSTANCE":
            return String(self.value * times.value)
        return String(self.value * times)
    
    // Character access and slicing
    spell char_at(index):
        if index < 0 or index >= len(self.value):
            return ""
        return self.value[index]
    
    spell get(index):
        return self.char_at(index)
    
    spell slice(start, end=None):
        result = []
        if end == None:
            end = len(self.value)
        
        if start < 0:
            start = len(self.value) + start
        if end < 0:
            end = len(self.value) + end
            
        for i in range(start, end):
            if i >= 0 and i < len(self.value):
                result = result + [self.value[i]]
        
        return String("".join(result))
    
    // Search methods
    spell contains(substring):
        sub = str(substring)
        for i in range(len(self.value) - len(sub) + 1):
            found = True
            for j in range(len(sub)):
                if self.value[i + j] != sub[j]:
                    found = False
                    break
            if found:
                return True
        return False
    
    spell index_of(substring):
        sub = str(substring)
        for i in range(len(self.value) - len(sub) + 1):
            found = True
            for j in range(len(sub)):
                if self.value[i + j] != sub[j]:
                    found = False
                    break
            if found:
                return i
        return -1
    
    spell starts_with(prefix):
        pre = str(prefix)
        if len(pre) > len(self.value):
            return False
        
        for i in range(len(pre)):
            if self.value[i] != pre[i]:
                return False
        return True
    
    spell ends_with(suffix):
        suf = str(suffix)
        if len(suf) > len(self.value):
            return False
        
        start = len(self.value) - len(suf)
        for i in range(len(suf)):
            if self.value[start + i] != suf[i]:
                return False
        return True
    
    // Transformation methods
    spell uppercase():
        result = ""
        for char in self.value:
            code = ord(char)
            if code >= 97 and code <= 122:  // a-z
                result = result + chr(code - 32)
            else:
                result = result + char
        return String(result)
    
    spell lowercase():
        result = ""
        for char in self.value:
            code = ord(char)
            if code >= 65 and code <= 90:  // A-Z
                result = result + chr(code + 32)
            else:
                result = result + char
        return String(result)
    
    spell capitalize():
        if len(self.value) == 0:
            return String("")
        
        first = self.value[0]
        code = ord(first)
        if code >= 97 and code <= 122:  // a-z
            first = chr(code - 32)
        
        return String(first + self.value[1:])
    
    spell trim():
        start = 0
        end = len(self.value)
        
        // Trim left
        while start < end and (self.value[start] == " " or self.value[start] == "\t" or self.value[start] == "\n"):
            start += 1
        
        // Trim right
        while end > start and (self.value[end - 1] == " " or self.value[end - 1] == "\t" or self.value[end - 1] == "\n"):
            end -= 1
        
        result = ""
        for i in range(start, end):
            result = result + self.value[i]
        
        return String(result)
    
    spell replace(old, new):
        old_str = str(old)
        new_str = str(new)
        
        if old_str == "":
            return String(self.value)
        
        result = ""
        i = 0
        while i < len(self.value):
            if i <= len(self.value) - len(old_str) and self.value[i:i+len(old_str)] == old_str:
                result = result + new_str
                i += len(old_str)
            else:
                result = result + self.value[i]
                i += 1
        
        return String(result)
    
    spell split(delimiter=" "):
        delim = str(delimiter)
        if delim == "":
            return [String(char) for char in self.value]
        
        result = []
        current = ""
        i = 0
        
        while i < len(self.value):
            if i <= len(self.value) - len(delim) and self.value[i:i+len(delim)] == delim:
                result = result + [String(current)]
                current = ""
                i += len(delim)
            else:
                current = current + self.value[i]
                i += 1
        
        if current != "" or self.value.ends_with(delim):
            result = result + [String(current)]
        
        return result
    
    // String comparison
    spell equals(other):
        if type(other) == "STRING":
            return self.value == other
        otherwise type(other) == "INSTANCE":
            if other.value:
                return self.value == other.value
        return self.value == str(other)
    
    // String representation
    spell to_str():
        return self.value
