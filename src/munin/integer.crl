grim Integer:
    init(value = 0):
        if type(value) == "INTEGER":
            self.value = value
        else:
            self.value = int(value)
    
    // Conversion methods
    spell to_float():
        return float(self.value)
    
    spell to_string():
        return str(self.value)
    
    spell to_boolean():
        return self.value != 0
    
    // Mathematical operations
    spell add(other):
        if type(other) == "INTEGER":
            return Integer(self.value + other)
        otherwise type(other) == "INSTANCE":
            if other.value:
                return Integer(self.value + other.value)
        return Integer(self.value + int(other))
    
    spell subtract(other):
        if type(other) == "INTEGER":
            return Integer(self.value - other)
        otherwise type(other) == "INSTANCE":
            if other.value:
                return Integer(self.value - other.value)
        return Integer(self.value - int(other))
    
    spell multiply(other):
        if type(other) == "INTEGER":
            return Integer(self.value * other)
        otherwise type(other) == "INSTANCE":
            if other.value:
                return Integer(self.value * other.value)
        return Integer(self.value * int(other))
    
    spell divide(other):
        if type(other) == "INTEGER":
            return Integer(self.value / other)
        otherwise type(other) == "INSTANCE":
            if other.value:
                return Integer(self.value / other.value)
        return Integer(self.value / int(other))
    
    spell modulo(other):
        if type(other) == "INTEGER":
            return Integer(self.value % other)
        otherwise type(other) == "INSTANCE":
            if other.value:
                return Integer(self.value % other.value)
        return Integer(self.value % int(other))
    
    spell power(exponent):
        if type(exponent) == "INTEGER":
            return Integer(self.value ** exponent)
        otherwise type(exponent) == "INSTANCE":
            if exponent.value:
                return Integer(self.value ** exponent.value)
        return Integer(self.value ** int(exponent))
    
    // Comparison operations
    spell equals(other):
        if type(other) == "INTEGER":
            return self.value == other
        otherwise type(other) == "INSTANCE":
            if other.value:
                return self.value == other.value
        return self.value == int(other)
    
    spell greater_than(other):
        if type(other) == "INTEGER":
            return self.value > other
        otherwise type(other) == "INSTANCE":
            if other.value:
                return self.value > other.value
        return self.value > int(other)
    
    spell less_than(other):
        if type(other) == "INTEGER":
            return self.value < other
        otherwise type(other) == "INSTANCE":
            if other.value:
                return self.value < other.value
        return self.value < int(other)
    
    // Utility methods
    spell abs():
        return Integer(abs(self.value))
    
    spell is_even():
        return self.value % 2 == 0
    
    spell is_odd():
        return self.value % 2 == 1
    
    spell is_positive():
        return self.value > 0
    
    spell is_negative():
        return self.value < 0
    
    spell is_zero():
        return self.value == 0
    
    // Range creation
    spell up_to(end):
        end_val = end
        if type(end) == "INSTANCE":
            end_val = end.value
        result = []
        for i in range(self.value, end_val):
            result = result + [Integer(i)]
        return result
    
    spell down_to(end):
        end_val = end
        if type(end) == "INSTANCE":
            end_val = end.value
        result = []
        for i in range(self.value, end_val, -1):
            result = result + [Integer(i)]
        return result
    
    // Iteration utilities
    spell times(callback):
        for i in range(self.value):
            callback(Integer(i))
        return self
    
    // String representation
    spell to_str():
        return str(self.value)
